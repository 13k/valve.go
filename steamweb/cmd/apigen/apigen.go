package main

import (
	"fmt"
	"path/filepath"
	"slices"

	"github.com/iancoleman/strcase"

	"github.com/13k/valve.go/steamlib"
	"github.com/13k/valve.go/steamweb/schema"
)

const (
	pkgPathNetHTTP = "net/http"
	pkgPathTesting = "testing"

	pkgBasePathTestify    = "github.com/stretchr/testify"
	pkgNameTestifyAssert  = "assert"
	pkgNameTestifyRequire = "require"

	pkgBasePath   = "github.com/13k/valve.go"
	pkgNameRoot   = "steamweb"
	pkgNameSchema = "schema"
	pkgNameSteam  = "steam"
	pkgNameDota2  = "dota2"

	fmtPkgNameTest = "%s_test"

	fnamefInterface = "z_%s.go"
	fnamefResults   = "z_%s_results.go"
	fnamefTests     = "z_%s_test.go"

	srcSchemaInterfacesCtor        = "MustNewInterfaces"
	srcSchemaInterface             = "Interface"
	srcSchemaInterfaceKey          = "InterfaceKey"
	srcSchemaMethodsCtor           = "MustNewMethods"
	srcSchemaMethod                = "Method"
	srcSchemaMethodKey             = "MethodKey"
	srcSchemaMethodParamsCtor      = "NewMethodParams"
	srcSchemaMethodParam           = "MethodParam"
	srcClient                      = "Client"
	srcClientCtor                  = "New"
	srcRequest                     = "Request"
	srcRequestCtor                 = "NewRequest"
	srcfStructCtorName             = "New%s"
	srcfSchemaVarName              = "Schema%s"
	srcIntefaceMethodNotFoundError = "InterfaceMethodNotFoundError"

	commentDisclaimer           = "Code generated by steamweb. DO NOT EDIT."
	commentfDisclaimerInterface = "API interface: %s."
	commentfSchemaVar           = "%s stores the Interfaces for interface %s."
	commentfStruct              = "%s represents interface %s."
	commentfSupportedAppIDs     = "Supported AppIDs: %s."
	commentfSupportedVersions   = "Supported versions: %s."
	commentStructUndoc          = "This is an undocumented interface."
	commentfStructCtor          = "%s creates a new %s interface."
	commentfStructGetter        = "%s creates a new %s interface."
	commentfStructMethodHeader  = "%s creates a Request for interface method %s."
	commentStructMethodUndoc    = "This is an undocumented method."
	commentfParamsVersioned     = "Parameters (v%d)"
	commentParams               = "Parameters"
	commentfStructResult        = "%s holds the result of the method %s/%s."

	errfUnknownInterfaceFilename = "unknown filename for interface %q"
	errfUnknownHTTPMethod        = "unknown HTTP method %q of interface method %q/%q"

	testfInvalidErrorType = "invalid error type %T"
)

var (
	pkgPathTestifyAssert  = fmt.Sprintf("%s/%s", pkgBasePathTestify, pkgNameTestifyAssert)
	pkgPathTestifyRequire = fmt.Sprintf("%s/%s", pkgBasePathTestify, pkgNameTestifyRequire)

	pkgPathSteamwebSchema = fmt.Sprintf("%s/%s/%s", pkgBasePath, pkgNameRoot, pkgNameSchema)
	pkgPathSteamwebSteam  = fmt.Sprintf("%s/%s/%s", pkgBasePath, pkgNameRoot, pkgNameSteam)
	pkgPathSteamwebDota2  = fmt.Sprintf("%s/%s/%s", pkgBasePath, pkgNameRoot, pkgNameDota2)
)

var (
	schemaSpecs = map[string]*struct {
		Name      string
		PkgPath   string
		PkgName   string
		Filenames map[string]string
		RelPath   string
	}{
		"steam": {
			PkgPath:   pkgPathSteamwebSteam,
			PkgName:   pkgNameSteam,
			Filenames: filenamesSteam,
			RelPath:   "steam",
		},
		"dota2": {
			PkgPath:   pkgPathSteamwebDota2,
			PkgName:   pkgNameDota2,
			Filenames: filenamesDota,
			RelPath:   "dota2",
		},
	}
)

type APIGen struct {
	baseName       string
	interfaces     schema.InterfacesIndex
	groupedMethods schema.MethodGroupsByName
	methodsNames   []string
	appIDs         []steamlib.AppID
	requiredAppID  bool
	undoc          bool
	pkgPath        string
	pkgName        string
	testPkgName    string
	schemaVarName  string
	structName     string
	structCtorName string
	interfaceFile  *GeneratedFile
	resultsFile    *GeneratedFile
	testsFile      *GeneratedFile
}

func NewAPIGen(interfaces schema.InterfacesIndex, pkgPath, pkgName, outputDir, basefile string) (*APIGen, error) {
	baseName := interfaces.Name()
	appIDs := interfaces.AppIDs()
	groupedMethods := interfaces.GroupMethodsByName()

	testPkgName := fmt.Sprintf(fmtPkgNameTest, pkgName)
	structName := baseName
	structCtorName := fmt.Sprintf(srcfStructCtorName, structName)
	schemaVarName := fmt.Sprintf(srcfSchemaVarName, structName)
	interfaceFname := fmt.Sprintf(fnamefInterface, basefile)
	resultsFname := fmt.Sprintf(fnamefResults, basefile)
	testsFname := fmt.Sprintf(fnamefTests, basefile)
	interfaceFile := NewGeneratedFile(filepath.Join(outputDir, interfaceFname))
	resultsFile := NewGeneratedFile(filepath.Join(outputDir, resultsFname))
	testsFile := NewGeneratedFile(filepath.Join(outputDir, testsFname))
	methodsNames := make([]string, 0, len(groupedMethods))

	for name := range groupedMethods {
		methodsNames = append(methodsNames, name)
	}

	slices.Sort(appIDs)
	slices.Sort(methodsNames)

	undoc := true

	g := &APIGen{
		baseName:       baseName,
		interfaces:     interfaces,
		groupedMethods: groupedMethods,
		methodsNames:   methodsNames,
		appIDs:         appIDs,
		requiredAppID:  len(appIDs) > 0,
		undoc:          undoc,
		pkgPath:        pkgPath,
		pkgName:        pkgName,
		testPkgName:    testPkgName,
		structName:     structName,
		structCtorName: structCtorName,
		schemaVarName:  schemaVarName,
		interfaceFile:  interfaceFile,
		resultsFile:    resultsFile,
		testsFile:      testsFile,
	}

	return g, nil
}

func (g *APIGen) methodFuncName(methodName string) string {
	if methodName[0] >= 'a' && methodName[0] <= 'z' {
		return strcase.ToCamel(methodName)
	}

	return methodName
}

func (g *APIGen) methodResultStructName(methodName string) string {
	return g.structName + g.methodFuncName(methodName)
}
